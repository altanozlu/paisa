package etf

import (
	"encoding/json"
	"log"
)

type AutoGenerated struct {
	Products []struct {
		ProductID   string `json:"productId"`
		ProductType string `json:"productType"`
		Composition struct {
			TotalNumberOfInstruments int `json:"totalNumberOfInstruments"`
			CompositionData          []struct {
				CompositionCharacteristics struct {
					Date          string  `json:"date"`
					Quantity      float64 `json:"quantity"`
					Bbg           string  `json:"bbg"`
					Name          string  `json:"name"`
					Weight        float64 `json:"weight"`
					Currency      string  `json:"currency"`
					Type          string  `json:"type"`
					Sector        string  `json:"sector"`
					Isin          string  `json:"isin"`
					CountryOfRisk string  `json:"countryOfRisk"`
				} `json:"compositionCharacteristics"`
				Weight float64 `json:"weight"`
			} `json:"compositionData"`
		} `json:"composition"`
	} `json:"products"`
}

func ParseAmundi(rawInformation []byte) []Standard {
	var ag AutoGenerated
	err := json.Unmarshal(rawInformation, &ag)
	if err != nil {
		log.Panicln(err)
	}
	stds := make([]Standard, 0)
	for _, comp := range ag.Products[0].Composition.CompositionData {
		secType := ""
		c := comp.CompositionCharacteristics
		if c.Type == "EQUITY_ORDINARY" {
			secType = "equity"
		} else if c.Type == "CASH" {
			secType = "cash"
		} else {
			// log.Println("unknown type", c.Type)
		}
		stds = append(stds, Standard{
			Name:         c.Name,
			ISIN:         c.Isin,
			Country:      c.CountryOfRisk,
			SecurityType: secType,
			Industry:     c.Sector,
			Weighting:    comp.Weight,
			Rating:       "",
		})
	}
	return stds
}
